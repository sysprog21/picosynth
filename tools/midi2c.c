/*
 * Convert human-readable MIDI notation to C arrays
 *
 * Usage:
 *   midi2c input.txt > melody.h
 *   midi2c < input.txt > melody.h
 *
 * Input format (one note per line):
 *   C4 4      # C4 quarter note
 *   D#5 2     # D#5 half note
 *   - 4       # rest
 *   R 2       # rest
 *
 * Note format: [A-G][#b]?[0-9]
 *   C4 = middle C (MIDI 60)
 *   A4 = 440Hz (MIDI 69)
 */

#include <ctype.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_NOTES 1024
#define MAX_LINE 256

static const char *note_names[] = {
    "C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B",
};

/* Convert note name to semitone offset (0-11) */
static int note_to_semitone(const char *name)
{
    char upper = (char) toupper((unsigned char) name[0]);
    int base;

    switch (upper) {
    case 'C':
        base = 0;
        break;
    case 'D':
        base = 2;
        break;
    case 'E':
        base = 4;
        break;
    case 'F':
        base = 5;
        break;
    case 'G':
        base = 7;
        break;
    case 'A':
        base = 9;
        break;
    case 'B':
        base = 11;
        break;
    default:
        return -1;
    }

    /* Check for sharp/flat */
    if (name[1] == '#')
        base = (base + 1) % 12;
    else if (name[1] == 'b')
        base = (base + 11) % 12;

    return base;
}

/* Parse note string like "C4", "D#5", "Bb3" to MIDI number */
static int parse_note(const char *str)
{
    /* Rest */
    if (str[0] == '-' || str[0] == 'R' || str[0] == 'r')
        return 0;

    /* Parse note name */
    int semitone = note_to_semitone(str);
    if (semitone < 0)
        return -1;

    /* Find octave number */
    const char *p = str + 1;
    if (*p == '#' || *p == 'b')
        p++;

    int octave = atoi(p);
    if (octave < -1 || octave > 9)
        return -1;

    /* MIDI: C4 = 60 */
    int midi = (octave + 1) * 12 + semitone;

    /* Handle B# wrapping */
    if (str[0] == 'B' && str[1] == '#')
        midi += 12;

    if (midi < 0 || midi > 127)
        return -1;

    return midi;
}

/* Convert MIDI number back to note string */
static void midi_to_note(int midi, char *buf, size_t size)
{
    if (midi == 0) {
        snprintf(buf, size, "-");
        return;
    }
    int octave = (midi / 12) - 1;
    int note = midi % 12;
    snprintf(buf, size, "%s%d", note_names[note], octave);
}

int main(int argc, char **argv)
{
    FILE *fp = stdin;
    uint8_t notes[MAX_NOTES], beats[MAX_NOTES];
    int count = 0;
    char line[MAX_LINE];
    int line_num = 0;

    if (argc > 1) {
        if (strcmp(argv[1], "-h") == 0 || strcmp(argv[1], "--help") == 0) {
            printf("Usage: %s [input.txt]\n", argv[0]);
            printf("Convert MIDI notation to C arrays.\n\n");
            printf("Input format:\n");
            printf("  C4 4    -> MIDI 60, 4 beats\n");
            printf("  A#3 2   -> MIDI 58, 2 beats\n");
            printf("  - 4     -> rest, 4 beats\n");
            return 0;
        }
        fp = fopen(argv[1], "r");
        if (!fp) {
            fprintf(stderr, "Error: cannot open %s\n", argv[1]);
            return 1;
        }
    }

    while (fgets(line, sizeof(line), fp)) {
        line_num++;

        /* Skip comments and empty lines */
        char *p = line;
        while (isspace((unsigned char) *p))
            p++;
        if (*p == '\0' || *p == '#')
            continue;

        /* Parse note and beat */
        char note_str[16];
        int beat;
        if (sscanf(p, "%15s %d", note_str, &beat) != 2) {
            fprintf(stderr, "Error line %d: expected 'NOTE BEATS'\n", line_num);
            if (fp != stdin)
                fclose(fp);
            return 1;
        }

        int midi = parse_note(note_str);
        if (midi < 0) {
            fprintf(stderr, "Error line %d: invalid note '%s'\n", line_num,
                    note_str);
            if (fp != stdin)
                fclose(fp);
            return 1;
        }

        if (count >= MAX_NOTES) {
            fprintf(stderr, "Error: too many notes (max %d)\n", MAX_NOTES);
            if (fp != stdin)
                fclose(fp);
            return 1;
        }

        notes[count] = (uint8_t) midi;
        beats[count] = (uint8_t) beat;
        count++;
    }

    if (fp != stdin)
        fclose(fp);

    if (count == 0) {
        fprintf(stderr, "Error: no notes found\n");
        return 1;
    }

    /* Generate C header */
    printf("#ifndef __MELODY_H\n");
    printf("#define __MELODY_H\n\n");
    printf("/* Generated by midi2c - DO NOT EDIT */\n");
    printf("/* %d notes */\n\n", count);

    /* Human-readable comment */
    printf("/*\n");
    for (int i = 0; i < count; i += 8) {
        printf(" *");
        for (int j = i; j < i + 8 && j < count; j++) {
            char buf[8];
            midi_to_note(notes[j], buf, sizeof(buf));
            printf(" %s(%d)", buf, beats[j]);
        }
        printf("\n");
    }
    printf(" */\n\n");

    /* Notes array */
    printf("const uint8_t melody[] = {\n");
    for (int i = 0; i < count; i += 16) {
        printf("    ");
        for (int j = i; j < i + 16 && j < count; j++)
            printf("%d, ", notes[j]);
        printf("\n");
    }
    printf("};\n\n");

    /* Beats array */
    printf("const uint8_t melody_beats[] = {\n");
    for (int i = 0; i < count; i += 16) {
        printf("    ");
        for (int j = i; j < i + 16 && j < count; j++)
            printf("%d, ", beats[j]);
        printf("\n");
    }
    printf("};\n\n");

    printf("#endif /* __MELODY_H */\n");

    return 0;
}
